name: Agent Ping Labeler

on:
  pull_request: 
    types: [opened, synchronize, edited]
  pull_request_review_comment:
    types: [created, edited]
  issue_comment:
    types: [created, edited]

jobs: 
  manage-agent-labels:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents:   read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
      
      - name:   Manage agent ping labels
        uses: actions/github-script@v7
        with:
          script:   |
            const agentConfig = {
              '@senior-dev': 'needs-senior-dev',
              '@test-architect': 'needs-test-architect',
              '@benchmarker': 'needs-benchmarker',
              '#senior-dev': 'needs-senior-dev',
              '#test-architect': 'needs-test-architect',
              '#benchmarker': 'needs-benchmarker'
            };

            let prNumber;
            let searchText = '';

            // Determine PR number and text to search
            if (context.eventName === 'pull_request') {
              prNumber = context. payload.pull_request.number;
              searchText = context.payload.pull_request.body || '';
            } else if (context.eventName === 'pull_request_review_comment') {
              prNumber = context.payload. pull_request.number;
              searchText = context.payload.comment.body || '';
            } else if (context.eventName === 'issue_comment' && context.payload.issue. pull_request) {
              prNumber = context.payload.issue.number;
              searchText = context. payload.comment.body || '';
            } else {
              console.log('Not a PR event, skipping');
              return;
            }

            // Also check PR diff for code comments
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            for (const file of files) {
              if (file.patch) {
                searchText += '\n' + file.patch;
              }
            }

            // Find which agents need labels added (@ mentions)
            const labelsToAdd = new Set();
            for (const [ping, label] of Object.entries(agentConfig)) {
              if (ping. startsWith('@') && searchText.includes(ping)) {
                labelsToAdd.add(label);
              }
            }

            // Find which agents need labels removed (# resolutions)
            const labelsToRemove = new Set();
            for (const [resolved, label] of Object.entries(agentConfig)) {
              if (resolved.startsWith('#') && searchText.includes(resolved)) {
                labelsToRemove. add(label);
              }
            }

            // Get current labels on the PR
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const currentLabelNames = new Set(currentLabels.map(l => l. name));

            // Add new labels
            const newLabels = [... labelsToAdd]. filter(label => !currentLabelNames.has(label));
            if (newLabels.length > 0) {
              await github. rest.issues.addLabels({
                owner: context.repo. owner,
                repo: context. repo.repo,
                issue_number: prNumber,
                labels: newLabels
              });
              console.log(`Added labels: ${newLabels.join(', ')}`);
            }

            // Remove resolved labels
            for (const label of labelsToRemove) {
              if (currentLabelNames.has(label)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context. repo.repo,
                    issue_number: prNumber,
                    name: label
                  });
                  console.log(`Removed label: ${label}`);
                } catch (e) {
                  console.log(`Failed to remove label ${label}: ${e.message}`);
                }
              }
            }

            if (newLabels.length === 0 && labelsToRemove.size === 0) {
              console.log('No label changes needed');
            }
